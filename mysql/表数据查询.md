## 查询数据库
* ```show databases;```

## 查询表
* ```show tables;```

## 查询表的结构
```
  show columns from table_name like '%name';
  describe table_name;
```

## 命令行语句
* 竖向展示数据 ``` select * from tablename \G```
* 不执行命令 ``` select * from \c```
* 查询当前用户 ``` select user();```
* 查询当前时间 ``` select now();```

## 过滤where
* 操作符： 
  * 符号判断： =  <>  != <  <=  >  >=  
  * 数值区间：between  
  * in / not in
  * is null / is not null 
  * filed <=> null [用来和null进行相等判断的符号]
* 排序： 默认升序 asc ,倒序 desc
* 限制条数： limit (索引从0开始)
```
select * from table_name where price = "2.5" order by desc limit 5;
select * from tbname where age in (18, 20, 25);
select * from table_name where price between 2.5 and 5;
select * from table_name order by price desc, name; [按price降序排列, price相同的按name升序排列]
select * from table_name limit 5,3; [从第五条数据开始，但是索引是4；后面的3条数据]
```

## 模糊查询
<!-- 
    通配符 like
    操作： 
        % 0个，1个，多个字符
        _ 单个字符
-->
select * from table_name where price like 'l%';
select * from table_name where price like '_l';
select * from table_name where price like '__l';


## 正则匹配查询
<!-- 
    正则 regexp 匹配列数据中符合的行
    操作：
        .   匹配任意一个字符 
        |   或
        []  匹配几个字符之一 [^] 
        \\. 匹配特殊字符.（特殊字符 . + ? * | ) 等）

        * + ?  {n} {n,} {n,m} 指定匹配的数量
        ^ $ 定位符
 -->
 select * from table where price REGEXP '.000'
### 注意
    * like 和 % _ 配合使用 , % 表示多字符 _ 表示单子符
    * regexp  和 . [] \\.   => 匹配字符类型
                 + ? * {n}  => 匹配字符的数量
                 ^ $ => 匹配字符的位置


## 分组 用于分组计算聚合数据
* where 在分组前过滤数据, having在分组后过滤数据； where 排除的行不在分组中
* 聚合函数 在没有分组的情况下,作用与全局;有分组的情况下,作用于分组后的每组数据
* **分组后,然后输出这一类的数据（包括 聚合函数 处理后的数据）**
* 分组后的数据 一般在后面跟上 order by,对分组后的数据进行排序
### 
    分组, 是按照类型进行分类, 然后对每一类进行处理(聚合函数)
         分组前可以使用 where 进行数据过滤
         分组后可以使用 having 进行数据过滤
         一般会使用order by 进行数据排序
    不能用来获取每类中每一行的详细信息, 它获得是对类处理后的数据


## 子查询
* 嵌套子查询 从内往外依次查询
* 作为计算字段
> select id,name,(select count(*)from orders where orders.id = customers.id) as count from customers
> 对外层查询出的每一条值,根据子查询where条件进行查询 【这里是对每一个顾客进行count计算】


## 组合查询: 将多个查询结果当作单个查询结果集返回
* union 每个查询必须包含相同的列(列的值类型必须兼容), 自动去重 ； 但是使用 union all 不会自动去重
* 组合查询 只能使用一个 order by ,对整个结果集进行排序


## 联结查询
* a表的每一行和b表的每一行配对,返回匹配行 [联结条件 =]
>select * from a,b where a.id = b.id

* 没有条件的查询语句,返回a*b条数
> select * from a,b

* inner join [联结条件 inner join] ，on和where作用类似
>select * from a inner join b on a.id=b.id

* 自联结 [通常来替代子查询] 对同一表引用2次,但是还是需要联结
> select p1.name,p1.id from teacher as p1,teacher as p2 where p1.id=p2.id and p2.id=5

* 外部联结 left outer join / right outer join
    * 关联行和左侧表(cus)未关联行
    > select cus.id, ord.name from cus left outer join ord on cus.id = ord.id  
    * 关联行和右侧表(ord)未关联行
    > select cus.id, ord.name from cus right outer join ord on cus.id = ord.id  

* 联结是 查询符合条件的值, 外联结 还包含对应未联结数据