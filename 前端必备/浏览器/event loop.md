## 事件循环
* [参考文章](http://lynnelv.github.io/js-event-loop-browser)

* js引擎只能执行一个线程(主线程)

* 宏任务(macrotask)和微任务(microtask)
```js
  // 宏任务: 
  // 整体的js代码、事件回调、XHR回调、定时器、IO操作，UI render
  // 微任务:
  // promise回调、MutationObserver、process.nextTick、Object.observe

  // 事件循环: 
  // 1. 检查宏任务队列是否为空, 非空则到2，为空则到3
  // 2. 执行宏任务队列中的一个任务
  // 3. 检查相关微任务队列是否为空, 若有则到4，否则到5
  // 4. 执行微任务队列中的所有任务
  // 5. 执行视图更新

  // 问题一: 为什么会出现事件延迟执行的问题。
  // 解答: 触发dom绑定的事件, 事件回调函数会推入宏任务队列, 而此时的事件循环中, 正在执行耗时的任务,
  // 那么事件回调函数必须等待耗时完成后, 才会进行执行, 所以造成延迟

  // 问题二: for(var i = 0; i < 5; i++) { setTimeout(() => console.log(i),100)} 为什么值为5个5
  // 解答: 因为for循环中, 内置函数setTimeout执行了5次, 而回调函数不立即执行, 会被专门对象管理, 等待延迟时间过期后,才将回调函数推入宏任务队列,然后事件循环执行输出i(而for循环自身执行事件忽略, 在回调函数推入宏任务队列之前已执行完成, 此时i=5)

  // 视图渲染的时机
  // 1. 不是每轮事件循环都会执行视图更新，浏览器有自己的优化策略(例如把几次的视图更新累积到一起重绘)
  // 2. requestAnimationFrame回调的执行时机是在一次或多次事件循环的UI render阶段, 不是每一帧都执行requestAnimationFrame回调
```
