#1 React Version 16.8.6

#2 ReactDOM.js
  * render **项目开始位置, 一个项目只有一个起始点**
  * legacyRenderSubtreeIntoContainer `G538`
    1. 参数 parentComponent 为 null, children 为 react组建树, container 为 根dom元素
  * legacyCreateRootFromDOMContainer `493` **初始化时生成fiberRoot对象** 
    1. 删除根dom元素的 子元素
    2. new ReactSyncRoot[G367]函数, 参数 tag 为 LegacyRoot, 实例 唯一属性 _internalRoot 为 根fiber节点 [见#2-1]
    3. ReactSyncRoot和ReactRoot 共用 prototype对象
    4. 返回值(ReactSyncRoot的实例对象) 赋值给 根dom元素的_reactRootContainer属性
  * updateContainer [见#3] **初始化在 unbatchedUpdates函数中执行, 不会批量执行, 最终返回一个执行时间**

#2-1 ReactFiberRoot.js
  * createFiberRoot 
    1. 生成根fiber节点, root
    2. root.current 的值是一个 fiber对象uninitializedFiber(mode=NoMode)
    3. uninitializedFiber.stateNode 的值是 root

#3 ReactFiberReconciler.js
  * updateContainer `G305`
    * computeExpirationForFiber
    * updateContainerAtExpirationTime `G177`
      * getContextForSubtree **根据父组建来获取context**
      * scheduleRootUpdate `G127` 
        * createUpdate **生成更新对象**
        * enqueueUpdate **初始化, 生成一个新的更新队列;且赋值到updateQueue属性**
        * scheduleWork [见#4]

#4 ReactFiberWorkLoop.js
  * scheduleUpdateOnFiber `G360`
    * markUpdateTimeFromFiberToRoot **更新fiber对象的expirationTime**
    * getCurrentPriorityLevel **计算当前权重**
    * renderRoot `G802` **expirationTime:Sync;isSync:true**
      * prepareFreshStack **生成模块对象workInProgress值**
      * do-while循环 isSync ? workLoopSync : workLoop **初始化执行workLoopSync**
    * workLoopSync `G1234`
      * while循环 workInProgress!== null **执行performUnitOfWork(workInProgress)**
    * performUnitOfWork `1248`
      * 更具是否有debug, 使用不同的beginWork函数, 这里默认使用原本的
    * beginWork `2525`
      * 更具fiber.tag的类型 处理组建