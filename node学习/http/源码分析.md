## 从最简单的http.createServer(()=>{}).listen(port)说起, 我把它分成三个阶段: 启动阶段、第一次http请求、后续http请求
  * 启动阶段 分为2个部分
    * createServer部分, 在该部分中会生成一个server实例(生成该实例的类会最终继承到EventEmitter, 那么该实例可以使用’事件’), 在这个过程中主要关注2个属性(kIncomingMessage[位于_http_incoming模块],kServerResponse[_http_outgoing模块])和2个事件(request,connection), 在后续阶段都非常重要；      
    * listen部分, 在该部分经过很多的判断, 使用c++模块tcp_wrap生成Tcp实例对象(在7层模型中, tcp属于传输层), 然后会根据是否支持ipv6, 绑定ipv6/ipv4协议(这就是协议层,  表示层的实现 在http模块没有看到, https模块中有) , 然后就是对tcp绑定2个很重要的属性(后面是伪代码) Tcp.onconnection = onconnection函数 和 Tcp.owner_symbol = this; 然后是结合事件循环部分(没太搞清楚, 后续再说, 主要用到 next_tick函数)
  * 首次http请求
    tcp建立链接后, 会执行tcp的onconnection属性函数,  在该函数中, 判断是否超过最大链接数, 生成socket实例, 触发server的connection事件,  在该函数中对socket进行了一系列的处理, 生成parser(c++模块, HTTPParser类生成 ), 给parser绑定属性函数  onIncoming / kOnHeadersComplete
  * tcp保持链接, 继续发送http请求(首次http请求也会执行该部分)
    parser接受完头信息后, 会执行kOnHeadersComplete函数,
    * 生成 incoming对象(就是req对象, 这里通过操作, 最终执行的server. kIncomingMessage函数), 
    * 执行 parser. onIncoming函数, 最终执行server. kServerResponse函数, 生成 res对象, 然后对res绑定 finish事件；激活server的request事件, 执行我们自己写的回调函数; 等待 res的写入完成, 会经过EventEmitter中系列操作(懵逼中…), 执行finish事件绑定的回调。
	
	