单线程
    js在一个时间只能执行一个任务

任务队列
    同步任务,异步任务(setTimeout,setInterval,Dom事件,Promise等)

    注:  p = new Promise是立即执行的,但是 p.then绑定的回调函数 是异步的

    js从上往下执行,同步任务进入执行栈,
    异步任务不会进入执行栈(他会有相应的模块进行处理),然后等待time时间到达,才会进入异步任务队列,
    同步任务执行完,调用异步队列中的任务,
    循环处理

    dom事件
        dom元素绑定事件,用户点击操作(UI操作时),事件回调函数才会进入任务队列,
        但是如果此时有一个大计算的js同步任务在执行,那么该事件的回调函数必须等待js同步任务执行完成后,
        才会被调用,这就是造成卡顿的原因

例子:
    for(var i=0;i<4;i++){
        setTimeout(function(){
            console.log(i)
        },1000)
    }

    先执行同本任务for循环,异步任务setTimeout会先存放在timer对象中,
    在for循环的过程中不会立即放入任务队列,
    而是等到了1s之后(因为for循环执行时间很短,可以不计),四个setTimeout异步任务会一起进入任务队列,再依次执行;
    所以结果才是几乎同时出现4个4,而不是隔一秒出现一个4

    for(var i=0;i<4;i++){
        setTimeout(function(){
            console.log(i)
        },1000*i)
    }

    伪代码： 
        描述异步任务进入任务队列中的时间
        quene = []
        timer = {}
        第一次循环
            timer.t1 = setTimeout(()=>{},1000)   等待1秒后 quene.push(timer.t1)
        第二次循环
            timer.t2 = setTimeout(()=>{},1000)   等待2秒后 quene.push(timer.t2)
        第三次循环
            timer.t3 = setTimeout(()=>{},1000)   等待3秒后 quene.push(timer.t3)
        第四次循环
            timer.t4 = setTimeout(()=>{},1000)   等待4秒后 quene.push(timer.t4)

        描述异步任务执行时间
            for循环同步任务结束,查询任务队列中异步任务,队列不为空则执行异步任务[由于for循环执行时间很短,忽略不计]
            1s后,t1进行了队列,执行,输出当前作用域中的i,4;队列中为空
            1s后,t2进入了队列(t1等待1s进入队列,执行时间忽略,再过1s,t2进入队列),执行,输出当前作用域中的i,4;队列中为空
            ...
        

eventloop:
    执行栈中任务完成,会询问任务队列;
    有任务就移入执行栈,执行结束在询问任务队列;
    直到任务队列为空,此时执行栈会继续询问任务队列;
    一旦任务队列进入新任务,就将任务推至执行栈执行。
    