参考文献
    https://www.cnblogs.com/ranyonsue/p/5984001.html
    
http特点:
    1.简单快速 请求服务,只需发送请求方法和路径
    2.灵活 可以传输任意类型的对象
    3.无连接 每次连接只处理一次请求
    4.无状态 指协议对于事务处理没有记忆能力,每次请求数据重传
    
http报文:
    请求报文:
        请求行 请求方法 url 协议版本
        请求头  key-value
        空行
        请求体 请求数据
    响应报文:
        状态行 协议版本 状态码 状态信息
        响应头 key-value 
        空行
        响应体 响应数据

http状态码:
    1xx : 指示信息
    2xx : 成功
    3xx : 重定向
    4xx : 客户端错误
    5xx : 服务器端错误

    200 请求成功
    403 服务器收到请求，但拒绝服务
    404 资源不存在
    500 服务器不可预期错误
    503 服务器当前不能处理客户端的请求，一段时间后可能恢复正常

http方式:
    get,post,put,delete,head

get和post的区别:
    1. get产生的url地址可以被收藏,post不行
    2. get请求数据会被完整的保留在浏览器的历史记录,post不会
    3. get参数通过url传递,post放在request body中
    4. get参数通过url传递,post放在request body中
    5. get请求在url传参有大小限制,post没有
    

http持久化:
    Keep-Alive,建立一次连接,后端不断开链接,进行多次请求
    请求1->响应1->请求2->响应2->请求3->响应3

http管道化:
    1.基于持久化 http1.1
    2.get,head支持
    3.初次链接,需要判断后端是否支持管线化
    
    请求1->请求2->请求3->响应1->响应2->响应3

tcp
    三次握手:
    客户端 发送链接请求报文; 服务端接收到请求报文, 发送一个应答(同意连接); 客户端 收到同意应答, 再向服务端发送响应报文

    为什么 需要三次握手, 两次握手 就可以 建立连接?
    客户端向服务端 发送的请求报文 A超时, 重发机制 会再次发送报文B, 服务端响应报文B后, 建立了连接; 然后 又收到了报文A, 此时 返回应答, 但是客户端对于此报文 已关闭, 服务端 无法收到 确认报文, 导致一直等待。

    四次挥手:
    客户端向服务端发送 释放连接请求; 服务端 收到 释放连接请求后, 不在接受 客户端发送的数据, 连接释放; 
    服务端将需要返回的数据传送完成, 然后向客户端发送释放请求; 客户端收到释放请求后, 向服务端 发送确认应答。

    慢开始:
    传输 速度 慢慢变大.

https:
    http 传输数据, tls 对数据加密。
    加密: 
        对称加密: 同一个秘钥 加密和解密数据
        非对称加密: 公钥加密数据, 私钥解密数据。
    非对称加密交换秘钥:
        服务端公布公钥, 客户端获取 该公钥; 然后 客户端 生成私钥, 将自身私钥 用服务端的公钥加密, 然后发送给 服务端;
        服务端 再根据 自身的 私钥 解密 出 客户端的 私钥; 此时 服务端 有了客户端的私钥。
    
    浏览器怎么解密服务端返回的信息(https):
        客户端 发送一个随机值以及需要的协议和加密的方式;
        服务端 收到 客户端的随机值, 自身生成一个 随机数, 并且根据 客户端 需求的 协议 和 加密方式  进行对应的操作, 并且发送自身证书
        客户端 收到 服务端证书, 验证有效性后, 再次生成一个随机数, 通过 服务端 证书公钥 加密这个随机数 并且发送给服务端
        服务端 收到 客户端 加密的随机值, 使用自身的私钥 解密获取第三个随机值
        此时 服务端 和 客户端 拥有 3个随机值, 通过这三个 随机值 按照 之前的 加密方式生成秘钥, 此时 客户端 和服务端 可以通过这个秘钥加解密









