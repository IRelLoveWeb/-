## 如何分别全局和模块
 * TypeScript与ECMAScript 2015一样，任何包含顶级import或者export的文件都被当成一个模块。
 * 如果一个文件不带有顶级的import或者export声明，那么它的内容被视为全局可见的（因此对模块也是可见的）
 * 全局最好只定义类型,因为全局内容被使用,在编译成js的时候会因为找不到对应的js内容而报错,因为没有该依赖; 而只做类型注解,在变编译成js时因为没有在表达式中使用,不会导入该模块

## 模块的导入和导出
 * js模块中使用 ``` export | export default | import ```
 * TS中使用 ```import``` 
 * js模块中使用commonjs和amd的语法, ``` module.exports ```
 * TS中使用 ``` export = xx | import xx = require(xx) | import [* as] xx from xx```
 * 编译器根据 Classic或Node 策略没有找到模块, 则会尝试定位一个 外部模块声明
 * 相对导入在解析时是相对于导入它的文件，并且不能解析为一个外部模块声明。 你应该为你自己写的模块使用相对导入，这样能确保它们在运行时的相对位置。
 * 非相对模块的导入可以相对于baseUrl或通过paths路径映射来进行解析。 它们还可以被解析成 外部模块声明。 使用非相对路径来导入你的外部依赖。

## 模块解析策略
 * Classic或Node ;使用--moduleResolution标记来指定使用哪种模块解析策略。若未指定，在使用了 --module AMD | System | ES2015时的默认值为Classic，其它情况时则为Node。

## 编写自己的模块
   * 写模块: 
      * 1. 使用其他模块,那么自身也成为模块; 
      * 2. 只用全局,自身也全局
      * 3. interface或type【也可以包含其他,但是只使用类型】只有类型的 适用全局,方便类型检查
      * 4. namespace,class,const,let,function等 即有类型还有内容 适用模块, 其他模块需要使用
   * 其他模块使用该模块: 1.用到类型,使用全局 2.用到内容,使用模块 
   

## 根据编译时指定的模块目标参数,编译器会生成对应的模块加载系统 (参数module)

## 编译器在编译时 会检测是否每个模块都会在生成的JavaScript中用到
  * 一个模块标识符只在类型注解部分使用，并且完全没有在表达式中使用时，就不会生成 require这个模块的代码

## 非TypeScript编写的类库的类型，我们需要声明类库所暴露出的API
  * 声明不是“外部程序”的具体实现, 而是对api的描述; 它们通常是在 .d.ts文件里定义的

## 模块(文件)里不要使用命名空间(namespace)
 * 命名空间在使用模块时几乎没什么价值
 * 命名空间对于在全局作用域内对逻辑上相关的对象和类型进行分组是很便利的
 * 命名空间对解决全局作用域里命名冲突来说是很重要的
 * 命名空间或模块中成员只有export;该成员才能在外部可见
